---
title: "Retrofit Vignette"
author: "Roopali Singh"
date: "`r Sys.Date()`"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Retrofit Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

RETROFIT is a statistical method for reference-free deconvolution of spatial transcriptomics data to estimate cell type mixtures. In this Vignette, we will estimate cell type composition of a sample synthetic dataset. We will annotate cell types using either (a) an annotated single cell reference or (b) marker gene lists. 

## Package Installation

Install and load the package using the following steps:
<!-- adam: this is not usable before submitting to and accepted by Bioconductor -->
```{r, eval=FALSE}
if(!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("retrofit")
```

```{r, load_library}
library(retrofit)
```

## Spatial Transcriptomics Data

First load the ST data, using the following command:

```{r, data}
X         =read.csv("data/sample_x.csv", row.names = 1, check.names = FALSE)
```
The ST data matrix will consist of G genes and S spots i.e., a matrix of order G x S.

## Pre-processing ST data 

You may also pre-process the ST data, similar to STdeconvolve, using the following steps:
<!-- Xi: need the pre-processing steps done by Xi using STdeconvolve package -->

This code will do the following:
- remove spots with too few genes
- remove genes that are present in 100% of the spots
- remove genes that are present in less than 5% of the spots
- find over dispersed genes for deconvolution.

However, for this sample synthetic data we will skip this part.

## Reference-free Deconvolution

Initialize the following parameters for deconvolution:
Iter: Number of iterations (default = 4000)
L: Number of components required
Lamda (default value is 0.01)

After initialization, run retrofit on the data (X) as follows:

```{r, decompose}
Iter = 4000
L = 20
result = RetrofitDecompose(x, L=L, iterations=Iter, seed=12)
H = result["h"]
W = result["w"]
Theta =result["th"]
```

## Cell-type Annotation

After deconvolution of ST data, we have our estimates of W (a matrix of order G x L), H (a matrix of order L x S) and Theta (a vector of L components). 
Next, we need to annotate the components, to get the proportion of, say K, cell types. We can do this in two ways: (a) using an annotated single cell reference or (b) using the known marker genes. Hence, we can follow either of the sections below to produce the cell-type proportions along with the deconvolution in one step.

## (A) Cell-type annotation via annotated single cell reference

Load the single cell reference data:

```{r, data}
sc_ref   =read.csv("data/sc_ref.csv", row.names = 1, check.names = FALSE)
```
This file contains average gene expression values for G genes in K cell types i.e., a matrix of order G x K. Run the following command to get K cell-type mixtures from the ST data X:

```{r, annotate}
K = ncol(W) # number of cell types
result = RetrofitMapByCorrelation(sc_ref, K, W, H)
H_annot = result["h"]
W_annot = result["w"]
```
Above code assigns components to the cell type it has maximum correlation with. 

[Visualization here]

<!-- Adam: Is it possible to add the mapping matrix visualization to the above mapping function? I can share the code for the visualization. Extra code chunk will require normalization of W and sc_ref matrices, which we are doing anyway inside the function above. -->


## (B) Cell-type annotation via known marker genes

Load the marker gene list:

```{r, data}
marker_ref   =read.csv("data/marker_ref.csv", row.names = 1, check.names = FALSE)
```
This file contains the list of marker genes for K cell types. Run the following command to get K cell-type mixtures from the ST data X:

```{r, annotate}
K = unique(marker_ref$celltype) # number of cell types
result = RetrofitMapByCorrelation(marker_ref, K, W, H)
H_annot = result["h"]
W_annot = result["w"]
```

Above code assigns components to the cell type it has maximum average marker expression in. 

[Visualization here]

Steps (A) or (B) produce the cell-type proportions for each spot in the ST data, which will be stored in the matrix H_annot of order K x S.

## Deconvolution with annotation (Optional)

We can also deconvolve the ST data matrix along with cell-type annotation all in one step as follows:

```{r, run_retrofit}
Iter = 4000
K = 10 # number of cell types in reference
L = 20 # number of components
result = RetrofitMain(X, 
                      ref_cor = sc_ref,
                      iterations=Iter, 
                      L=L, 
                      K=K,
                      seed=12)
```
or

```{r, run_retrofit}
Iter = 4000
K = 10 # number of cell types in reference
L = 20 # number of components
result = RetrofitMain(X,
                      ref_marker=marker_ref,
                      iterations=Iter, 
                      L=L, 
                      K=K,
                      seed=12)
```

## Results and visualization

Since this is synthetic data, true cell type proportions are known. We can visualize the correlation and RMSE between true and estimated cell-type proportions as follows:

<!-- Adam: need the code to create RMSE and correlation plot for proportions i.e., cor(H, H_hat) and RMSE(H, H_hat) -->

```{r}
# H_annot: cell-annotated H result
H_annot = result["h"]

# References
library(DescTools)
H=read.csv("data/sample_h.csv", row.names = 1, check.names = FALSE)
X=read.csv("data/sample_x.csv", row.names = 1, check.names = FALSE)
sc_ref=read.csv("data/sc_ref.csv", row.names = 1, check.names = FALSE)

# Correlation(H, H_hat) - B:1 in figure2
H_cor=sort(diag(cor(H,H_annot)),decreasing=T,na.last=T)
H_cor_value = format(round(AUC(x=seq(0,1,length.out = 1000),y=H_cor),digits=3), nsmall = 3)
print(H_cor_value) # 0.964

# Correlation(X, X_hat) - D:1 in figure2
H_annot_norm=matrix(NA, ncol=ncol(H), nrow=nrow(H_annot))
for(i in 1:ncol(H)){
  H_annot_norm[,i]=H_annot[,i]/sum(H_annot[,i])
}
X_hat=as.matrix(sc_ref) %*% H_annot_norm
X_cor=sort(diag(cor(X,X_hat)),decreasing=T,na.last=T)
X_cor_value = format(round(AUC(x=seq(0,1,length.out = 1000),y=X_cor),digits=3), nsmall = 3)
print(X_cor_value) # 0.962
```

In case of real data, where ground truth is not available, we can do certain diagnostics on the quality of results. For example, compute the correlation between marker expression (if known) and cell type proportion in ST data and visualize the agreement of the spatial pattern between markers and estimated proportion (read the paper for more information).

# Session information

```{r}
sessionInfo()
```



