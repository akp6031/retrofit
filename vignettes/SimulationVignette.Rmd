---
title: "Retrofit Simulation Vignette"
author: "Adam Keebum Park, Roopali Singh"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Retrofit Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = 'hide')
```

## Introduction

RETROFIT is a statistical method for reference-free deconvolution of spatial transcriptomics data to estimate cell type mixtures. In this Vignette, we will estimate cell type composition of a sample synthetic dataset. We will annotate cell types using an annotated single cell reference.

## Package Installation

Install and load the package using the following steps:
```{r, eval=FALSE}
if(!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("retrofit")
```

The main functionalities of RETROFIT are covered in this tutorial.
```{r, load_library}
library(retrofit)
```

## Spatial Transcriptomics Data

First load the ST data, using the following command:
```{r, data}
data("VignetteSimulationData")
x = data$n10m3_x
```
The ST data matrix will consist of G = 500 genes and S = 1000 spots i.e., a matrix of order G x S.

## Reference-free Deconvolution

Initialize the following parameters for deconvolution:
iterations: Number of iterations (default = 4000)
L: Number of components required
seed: Seed for controlling random number generation of R

After initialization, run retrofit on the data (X) as follows:
```{r, decompose}
iterations  = 10
L           = 20
seed        = 12
result      = retrofit::decompose(x, L=L, iterations=iterations, seed=seed, verbose=TRUE)
H           = result$h
W           = result$w
Theta       = result$th
```

### Deconvolution with more iterations for reproducibility

For reproducing the exact results introduced in the paper, 
4000 iterations are required to stabilize the decomposed matrices.
The whole computation is omitted here due to time complexity (> 10min)
```{r, load_retrofit_results}
H           = data$results_4k_iterations$decompose$h
W           = data$results_4k_iterations$decompose$w
Theta       = data$results_4k_iterations$decompose$th
################################################################################
# The above results are obtained by running the code below.
# iterations = 4000
# result      = decompose(x, L=L, iterations=iterations, seed=seed, verbose=TRUE)
################################################################################
```

## Cell-type Annotation via annotated single cell reference

After deconvolution of ST data, we have our estimates of W (a matrix of order G x L), H (a matrix of order L x S) and Theta (a vector of L components). 
Next, we need to annotate the components, to get the proportion of, say K, cell types. We can do this in two ways: (a) using an annotated single cell reference or (b) using the known marker genes. Here, we will annotate using single cell reference.

Get the single cell reference data:
```{r, reference}
sc_ref_w = data$sc_ref_w
```

This file contains average gene expression values for G genes in K cell types i.e., a matrix of order G x K. Run the following command to get K cell-type mixtures from the ST data X:
```{r, annotate}
K         = 10
result  = retrofit::annotateWithCorrelations(sc_ref=sc_ref_w, K=K, decomp_w=W, 
                                             decomp_h=H)
H_annot = result$h
W_annot = result$w
ranked_cells        = result$ranked_cells
```
Above code assigns components to the cell type it has maximum correlation with.

## Deconvolution with annotation (Optional)

We can also deconvolve the ST data matrix along with cell-type annotation all in one step, as follows:
```{r, retrofit}
iterations  = 10
L           = 20
K           = 10 
seed        = 12 
result = retrofit::retrofit(x, 
                            sc_ref=sc_ref_w,
                            iterations=iterations, 
                            L=L, 
                            K=K,
                            seed=seed)
```

## Results and visualization

Since this is synthetic data, true cell type proportions are known. We can visualize the correlation and RMSE between true and estimated cell-type proportions as follows:

Below code plots the correlation matrix.
```{r, visualize_correlation_matrix}
correlations = cor(sc_ref_w[ranked_cells], W_annot[,ranked_cells])
ggcorrplot::ggcorrplot(correlations)
```

Below code plots the correlation values between each cell type and the chosen component.
```{r, visualize_correlations}
# correlation between true and estimated cell-type proportions
library(ggplot2)
ranked_correlations = sort(diag(correlations), decreasing=T)
df=data.frame(x=1:length(ranked_correlations), 
              y=ranked_correlations, 
              label_x1=1, 
              label_x2=2, 
              label_y=seq(from=0.5, by=-0.05, length.out=10),
              label_cell=ranked_cells,
              label_corr=format(round(ranked_correlations, digits=4)))

gg <- ggplot(df,aes(x=x, y=y, group=1)) + 
  geom_line(aes(x=x, y=y)) + geom_point(aes(x=x, y=y)) + theme_bw() + ylim(0, 1.05) +
  geom_text(data=df, aes(x=label_x1, y=label_y, label=label_corr), size=4, hjust=0) +
  geom_text(data=df, aes(x=label_x2, y=label_y, label=label_cell), size=4, hjust=0)
plot(gg)
```

Below code visualize RMSE between true and estimated cell-type proportions.
```{r, visualize_rmse}
H_True=data$sc_ref_h
H=H_annot

rmse=NULL
for(i in 1:ncol(H_True)){
  H_True_i=H_True[,i]/sum(H_True[,i])
  H_i=H[,i]/sum(H[,i])
  rmse=c(rmse,sqrt(mean((H_True_i-H_i)^2)))
}
df=data.frame(x=1, y=rmse)

gg <- ggplot(df,aes(x=x,y=y, fill=x)) + 
  geom_violin(lwd=0) + theme_bw() + xlim(0,5) + ylim(0, 0.75) +
  theme(legend.position = "None",
        axis.title=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_text(size=10))
plot(gg)
```

In case of real data, where ground truth is not available, we can do certain diagnostics on the quality of results. For example, compute the correlation between marker expression (if known) and cell type proportion in ST data and visualize the agreement of the spatial pattern between markers and estimated proportion (read the paper for more information).

# Session information

```{r}
sessionInfo()
```
